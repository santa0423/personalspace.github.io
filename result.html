<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>나의 팟 테스트 결과</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="result.css" />
    <!-- html2canvas: 모바일에서 이미지 저장용 -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js" defer></script>
  </head>
  <body>
    <div class="viewport">
      <div class="frame" id="printArea">
        <div class="canvas">
          <!-- 상단 -->
          <header class="top">
            <h1 class="page-title">나의 팟 테스트 결과</h1>
          </header>

          <!-- 시드 & 레이어 -->
          <section class="hero">
            <div class="rings">
              <div class="ring outer"></div>
              <div class="ring inner"></div>
            </div>
            <img class="seed" src="images/seed.png" alt="" onerror="this.classList.add('fallback')" />
          </section>

          <!-- 범례 -->
          <div class="legend">
            <div class="lg"><span class="dot dot-avg"></span>평균</div>
            <div class="lg"><span class="dot dot-me"></span>나</div>
          </div>

          <!-- 요약 -->
          <section class="summary">
            <div class="score-card">
              <div class="score-num" id="scoreTotal">--</div>
              <div class="score-unit">점</div>
              <div class="score-sub">
                <span class="badge-up" id="rankText">상위 —%</span><br />
                <span class="delta"><i>▲</i> <span id="deltaText">평균보다 —점 높습니다</span></span>
              </div>
            </div>

            <article class="insight-card">
              <p class="insight-text">
                <b id="typeStrong">당신의 퍼스널 스페이스는 …</b><br />
                <span id="insightDetail">결과를 계산하고 있어요.</span>
              </p>
            </article>
          </section>

          <!-- 영역별 -->
          <section class="zones">
            <h2 class="zones-title">나의 팟 영역</h2>
            <div class="bar">
              <span class="label">터치존</span>
              <div class="rail"><div class="fill" id="barTouch"></div></div>
            </div>
            <div class="bar">
              <span class="label">마인드존</span>
              <div class="rail"><div class="fill" id="barMind"></div></div>
            </div>
            <div class="bar">
              <span class="label">디지털존</span>
              <div class="rail"><div class="fill" id="barDigital"></div></div>
            </div>
          </section>

          <!-- CTA -->
          <div class="cta-wrap">
            <button class="btn primary" id="actionBtn">인쇄해서 자세히 보기</button>
            <button class="btn ghost" id="homeBtn">
              <span class="chev">‹</span> 처음으로 돌아가기
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const TOUCH_IDX = [5,7,8,17,20].map(n=>n-1);
      const MIND_IDX  = [6,9,10,11,12,13,16,15].map(n=>n-1);
      const DIGI_IDX  = [2,3,4,18,19].map(n=>n-1);

      const scoreEl = document.getElementById('scoreTotal');
      const rankText = document.getElementById('rankText');
      const deltaText = document.getElementById('deltaText');
      const barTouch = document.getElementById('barTouch');
      const barMind = document.getElementById('barMind');
      const barDig = document.getElementById('barDigital');
      const typeStrong = document.getElementById('typeStrong');
      const insDetail = document.getElementById('insightDetail');

      const actionBtn = document.getElementById('actionBtn');
      const homeBtn = document.getElementById('homeBtn');
      const frame = document.getElementById('printArea');

      let answers = [];
      try {
        const raw = localStorage.getItem('keepod_answers');
        if (raw) answers = JSON.parse(raw);
      } catch(e){}

      if (!Array.isArray(answers) || answers.length !== 20) {
        location.href = 'test.html?reset=1';
      }

      const cleaned = answers.map(v => (v == null ? 0 : Number(v)));
      const sum = arr => arr.reduce((a,b)=>a+b,0);
      const total = sum(cleaned);
      const avg = total / 20;

      const refAvg = 68;
      const delta = total - refAvg;
      const percentile = Math.max(0, Math.min(100, total));

      scoreEl.textContent = total;
      deltaText.textContent = (delta >= 0 ? `평균보다 ${delta}점 높습니다` : `평균보다 ${Math.abs(delta)}점 낮습니다`);
      rankText.textContent = `상위 ${Math.round(percentile)}%`;

      let typeName = "넓은 경계형";
      let detail = "주변과의 간격을 여유 있게 두며 안정감을 추구해요. 특히 터치존에서의 거리 유지가 중요한 편이에요. 마인드존과 디지털존에서는 비교적 유연하지만 상황에 따라 예민해질 수 있어요.";
      if (avg < 2.3) { typeName = "개방형"; detail = "대체로 유연하며 상황 변화에 강해요. 다만 필요할 때 경계를 분명히 하는 연습이 도움이 됩니다."; }
      else if (avg < 3.2) { typeName = "균형형"; detail = "상황에 따라 경계를 조절할 줄 알아요. 불편 신호를 조기에 인지해 부드럽게 선을 제시해보세요."; }
      else if (avg < 4.0) { typeName = "신중형"; detail = "개인적 공간과 감정의 안정이 중요해요. 사전 공지나 거리두기 전략을 사용하면 소진을 줄일 수 있습니다."; }

      typeStrong.textContent = `당신의 퍼스널 스페이스는 ${typeName}이에요.`;
      insDetail.textContent = detail;

      const partAvg = idxs => {
        const vals = idxs.map(i => cleaned[i] || 0);
        return Math.round((sum(vals)/(idxs.length*5))*100);
      };

      barTouch.style.width = partAvg(TOUCH_IDX) + '%';
      barMind.style.width = partAvg(MIND_IDX) + '%';
      barDig.style.width = partAvg(DIGI_IDX) + '%';

      // 홈
      homeBtn.addEventListener('click', () => {
        localStorage.removeItem('keepod_answers');
        location.href = 'index.html';
      });

      // ===== 모바일/데스크톱 분기 =====
      function isMobileView() {
        const vw = (window.visualViewport && window.visualViewport.width) || window.innerWidth;
        const vh = (window.visualViewport && window.visualViewport.height) || window.innerHeight;
        return (vw < 700) || (vh < 900);
      }

      // 데스크톱: 인쇄 / 모바일: 이미지 저장
      function setActionBehavior() {
        if (!isMobileView()) {
          actionBtn.textContent = '인쇄해서 자세히 보기';
          actionBtn.onclick = () => {
            frame.style.width = "176mm";
            frame.style.height = "250mm";
            frame.style.borderRadius = "0";
            frame.style.boxShadow = "none";
            window.print();
            frame.style.width = "";
            frame.style.height = "";
            frame.style.borderRadius = "";
            frame.style.boxShadow = "";
          };
        } else {
          actionBtn.textContent = '이미지로 저장하기';
          actionBtn.onclick = async () => {
            // 캡처용 클론을 화면 밖에 만들어 변형(scale) 영향 제거
            const BASE_W = 564, BASE_H = 900;
            const clone = frame.cloneNode(true);
            clone.id = 'capture-clone';
            Object.assign(clone.style, {
              position: 'fixed',
              left: '-99999px',
              top: '0',
              width: BASE_W + 'px',
              height: BASE_H + 'px',
              transform: 'none',
              transformOrigin: 'top left',
              borderRadius: '0',
              boxShadow: 'none',
              background: '#f6f6f6',
              zIndex: '-1'
            });
            document.body.appendChild(clone);

            try {
              const canvas = await html2canvas(clone, {
                backgroundColor: '#f6f6f6',
                scale: Math.min(3, (window.devicePixelRatio || 2)), // 적당한 해상도
                useCORS: true,
                logging: false
              });
              const dataURL = canvas.toDataURL('image/png');

              // iOS 사파리 대응: 새 탭 열기 fallback
              const a = document.createElement('a');
              a.href = dataURL;
              a.download = `keepod_result_${Date.now()}.png`;
              document.body.appendChild(a);
              a.click();
              a.remove();
              // download 미지원 브라우저는 새창으로
              if (!('download' in HTMLAnchorElement.prototype)) {
                window.open(dataURL, '_blank');
              }
            } catch (e) {
              alert('이미지 저장 중 문제가 발생했습니다. 스크린샷을 이용해 주세요.');
              console.error(e);
            } finally {
              clone.remove();
            }
          };
        }
      }

      window.addEventListener('resize', setActionBehavior);
      window.addEventListener('orientationchange', setActionBehavior);

    // ===== 하이브리드 스케일: 세로 꽉 채우기 + 좌우 안전(최대 3%만 가로 압축) =====
(function () {
  const BASE_W = 564;
  const BASE_H = 900;
  const MAX_SQUISH = 0.97; // 가로 최소 비율(=최대 3% 압축). 0.97~1 사이만 허용
  const frameEl = document.querySelector('.frame');

  function vp() {
    const vw = (window.visualViewport && window.visualViewport.width) || window.innerWidth;
    const vh = (window.visualViewport && window.visualViewport.height) || window.innerHeight;
    return { vw, vh };
  }

  function applyScale() {
    const { vw, vh } = vp();
    const isMobile = (vw < 700) || (vh < 900);

    if (!isMobile) {
      // 태블릿/PC: 원본 픽셀 고정
      frameEl.style.position = 'static';
      frameEl.style.transform = 'none';
      frameEl.style.width  = BASE_W + 'px';
      frameEl.style.height = BASE_H + 'px';
      return;
    }

    // 1) 기본: 세로 꽉 채우기
    const sH = vh / BASE_H;
    const needW = BASE_W * sH;

    if (needW <= vw) {
      // 가로가 화면 안에 들어오면 그대로(위아래 빈 공간 0)
      const tx = (vw - needW) / 2;
      frameEl.style.width  = BASE_W + 'px';
      frameEl.style.height = BASE_H + 'px';
      frameEl.style.position = 'fixed';
      frameEl.style.top = '0';
      frameEl.style.left = '0';
      frameEl.style.transformOrigin = 'top left';
      frameEl.style.transform = `translate(${tx}px, 0) scale(${sH})`;
      return;
    }

    // 2) 살짝만 가로 압축해서 폭 맞추기 (최대 3%)
    const fitRatio = vw / needW; // 1보다 작으면 넘침
    if (fitRatio >= MAX_SQUISH) {
      // 세로 스케일은 유지하고, 가로만 fitRatio 만큼 압축
      const tx = 0; // 가로 꽉 채웠으니 좌표는 0
      frameEl.style.width  = BASE_W + 'px';
      frameEl.style.height = BASE_H + 'px';
      frameEl.style.position = 'fixed';
      frameEl.style.top = '0';
      frameEl.style.left = '0';
      frameEl.style.transformOrigin = 'top left';
      // scaleY는 sH, scaleX는 sH*fitRatio 와 동일 효과: scale(sH) 후 scaleX(fitRatio)
      frameEl.style.transform = `translate(${tx}px, 0) scale(${sH}) scaleX(${fitRatio})`;
      return;
    }

    // 3) 그래도 넘치면 어쩔 수 없이 contain (좌우/상하 모두 안전, 중앙 정렬)
    const sW = vw / BASE_W;
    const s = Math.min(sW, sH);
    const tx = (vw - BASE_W * s) / 2;
    const ty = (vh - BASE_H * s) / 2;
    frameEl.style.width  = BASE_W + 'px';
    frameEl.style.height = BASE_H + 'px';
    frameEl.style.position = 'fixed';
    frameEl.style.top = '0';
    frameEl.style.left = '0';
    frameEl.style.transformOrigin = 'top left';
    frameEl.style.transform = `translate(${tx}px, ${ty}px) scale(${s})`;
  }

  window.addEventListener('resize', applyScale);
  window.addEventListener('orientationchange', applyScale);
  applyScale();
})();


    </script>
  </body>
</html>
